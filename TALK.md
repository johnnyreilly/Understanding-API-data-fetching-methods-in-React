---
theme: "night"
transition: "slide"
highlightTheme: "monokai"
logoImg: data:image/png;base64,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
slideNumber: false
showNotes: false
title: "TypeScript 4.4 more readable code - LogRocket with @johnny_reilly"
---
<!-- .slide: data-transition="slide" data-background="./images/typescript-4-4-more-readable-code.png"  -->
## TypeScript 4.4 :
## more readable code
### [LogRocket](https://www.logrocket.com) with [@johnny_reilly](https://twitter.com/johnny_reilly)

<aside class="notes">
talk to be delivered using VS Code Reveal extension: https://github.com/evilz/vscode-reveal
150% zoom for playground
general welcome
</aside>

---

<!-- .slide: data-transition="slide" data-background="./images/typescript-4-4-more-readable-code.png" -->
## `whoami`

- [@johnny_reilly](https://twitter.com/johnny_reilly) ‚ù§Ô∏èüåª

- Blogging and open-source software

 - TypeScript
   - DefinitelyTyped
   - ts-loader
   - fork-ts-checker-webpack-plugin

<aside class="notes">
Hi everyone,

My name is John Reilly and I'm a big fan of TypeScript.

I'm an early adopter, I started using it right back when 0.8 was initially announced. I love static typing. 

definitely typed / ts-loader / fork-ts-checker-webpack-plugin (webpack)
</aside>

---

<aside class="notes">
Like all good talks, this began with a tweet.
I spotted, in my inbox, an automated email
from GitHub. There'd been some activity on a
GitHub issue I subscribed to, by my coding hero
Anders Hejlsberg.

It turned out that a very long lived issue
had just been resolved by a PR of Anders'.
I tweeted about it because I was excited about it
</aside>

[![Screenshot of initial tweet](images/tweet-screenshot.png =500x)](https://www.twitter.com/johnny_reilly/status/1408162514504933378)

---

<aside class="notes"> 
I wasn't the only one!

You can see from one of the reactions here
that this change has a major impact on the
readability of code in TypeScript

That's what we're going to look into today.
</aside>

[![Screenshot of reactions on Twitter](images/reactions-on-twitter.png =400x)](https://twitter.com/zeh/status/1408208125572915202)

---

<!-- .slide: data-transition="slide" data-background="./images/announcing-typescript-0-8-background.png" data-background-transition="zoom" -->

<aside class="notes">

In the early days of TypeScript, the type system
was a great deal more limited. Union types
did not exist.

*COMPLICATED! REPEAT!*  

This meant, when writing a function that had
parameters that could be of various types,
the only way to model this was by using the top
type of `any`

> A top type is a supertype of every other type

</aside>

## In the beginning...
## TypeScript was `void`

## and `any`  {.fragment .fade-up}

---

<aside class="notes">

We're going to write a simple function in this talk
that is as type safe and readable as it can be

We'll look at how TypeScript has facilitated that
as it has evolved as a language.

We'll see that over time both readability
and type safety improve

</aside>

## The mission:
## write type safe code
## that is readable

---

<aside class="notes">

We're going to write 
an "add" function; a simple mechanism 
for adding up numbers,

</aside>

## add([1, '7', '3', 9])

---

<!-- .slide: style="text-align: left;" -->
<aside class="notes">

The year is 2012, TS version 0.8

Here's an implementation of our adder function
You can see that it would take our combination
of strings and numbers and would add them 

But - it's not type safe at all. We check at runtime
that types are correct

</aside>

[We begin with vanilla JS:](https://www.typescriptlang.org/play?noImplicitAny=false&ts=3.3.3#code/GYVwdgxgLglg9mABAQwCaoBRQBYzAcwGcAVOAQXQEpEBvAKEUcQBsBTKRKOKZZxAXkQAGANwMmwOACdEGCAkIccefKQqpEcYJ1wES5KrXFMmMbVgCeAB1ZadKtegH9BAckVSVr6vRN+mXDx8ANSCAHIgALYARqxSWLqqBqiUYv6MAL6IrMyErIhmslDWttrKBI4aLm5gUbFS3kbpfoG8iKH2Fclp6Vk5eU3NAdhScADuiGCsEwCiUqPxrmDciGPYyBwAktkAHjbQrKjePf4ZxohnJlLsIFJIrcxiZ0A)

```ts
function add(thingsToAdd) {
    let total = 0;
    for (const thingToAdd of thingsToAdd) {
        if (typeof thingToAdd === 'string') {
            total += Number(thingToAdd);
        } else if (typeof thingToAdd === 'number') {
            total += thingToAdd;
        } else {
            throw new Error('not what I expected');
        }
    }
    return total;
}
```

---

<aside class="notes">

The year is 2015

When TypeScript 1.4 landed it brought
a new feature called "union types"
which enabled the modelling of a variable
having multiple explicit types.

It had a sister feature called "type aliases"
which "variable-ified" a type, thus reducing verbosity.

With it came type guards; typescript is now
type narrowing aware!


Interestingly union types had already landed
in Flow and up to that point in time, were
a compelling reason to favour Flow over
TypeScript

</aside>

### TypeScript 1.4
#### State of the union (type)

- [Union types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-4.html#union-types)
- [Type aliases](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-4.html#type-aliases)
- [Type guards](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-4.html#type-guards)

---

<!-- .slide: style="text-align: left;" -->
<aside class="notes">

TypeScript uses `typeof` to narrow types in the type system

</aside>

[Applied union types:](https://www.typescriptlang.org/play?ts=4.4.2#code/GYVwdgxgLglg9mABAQwCaoBRQBYzAcwGcAVOAQXQC5EMwQBbAIwFMAnRAH0UKlb3wCUAbQC6A6nSZtEAbwBQiRYgA2zKIihwoyZYgC8iAAwBuBUuBx2GCAh4bcBUhVSI4we-xLl0A2WaVKMO5YAJ4ADsxuHo7eLnrxiADkPHwEib7yAVlKmtq6ANQGAHIMLKxYDvhOPqbZigC+iszKhMyIQTRQ4ZHuOPzVcQmJkmXpfnVZuTqIhdFVsbV1jc2t4xNKAPQbiADqAKKIACIA8kWJxIhFe3uHiMQAEgCSAMoAhP7rOKxwAO6IYMw-ntWN9ysMtIgfthkOpHohmAAPCLQZiodKLbL1D5YgKsNQgVhIKbKUxYuQ2MCEOCqAB0yjg+AwaEwQgAjAAaJIAdkSnMSAGZeYgAJxiARAA)

```ts
any -> number | string
```

```ts
function add(thingsToAdd: (number | string)[]): number {
    let total = 0;
    for (const thingToAdd of thingsToAdd) {
        if (typeof thingToAdd === 'string') {
            total += Number(thingToAdd);
        }  else if (typeof thingToAdd === 'number') {
            total += thingToAdd;
        } else {
            // WE DON'T NEED THIS!
            throw new Error('not what I expected');
        }
    }
    return total;
}
```

---

<!-- .slide: style="text-align: left;" -->
<aside class="notes">

Talk through function - we are now both:
- type safe
- and have an expressively named type

But this could still be made better...

</aside>

[Applied type aliases:](https://www.typescriptlang.org/play?ts=3.3.3#code/C4TwDgpgBAcgrgWwEYQE4HlUGVioJYB2A5lALxQGIqpQA+UAzroUQFCsBmcBAxsHgHsCUAIYATMQApgACxYMAKgICCEgFywqaTDnzEA2gF0AlBsrI0UAN6sodqABsIwKMAHARDslAAMAblt7DgEaSR4hJlc5YiVVMSgBDij5WIlja0D7ezwk6XAIROSYlQkyUnIAciY9Igr0myzG+zcPLwBqcngLVGloolSxYwCmuwBfKAgHBmgGkayWzygOov6SsWGR0cyoLazUZzhUYQWHAK3WcIIGAScAOgcBIklxKX0ARgAaKAqAdgqvioAZn+UAAnCZjEA)

```ts
(number | string) -> NumberOrString
```

```ts
type NumberOrString = number | string

function add(thingsToAdd: NumberOrString[]): number {
    let total = 0;
    for (const thingToAdd of thingsToAdd) {
        if (typeof thingToAdd === 'string') {
            total += Number(thingToAdd);
        } else {
            total += thingToAdd;
        }
    }
    return total;
}
```

---

<aside class="notes">

The year is 2021

The next thing we want to talk about is the exciting
feature that ships with TS 4.4.

The title is not catchy - so let's look at what it unlocks

</aside>

### TypeScript 4.4

- [Control Flow Analysis of Aliased Conditions and Discriminants](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-4.html#control-flow-analysis-of-aliased-conditions-and-discriminants)

---

<!-- .slide: style="text-align: left;" -->
<aside class="notes">

Here we've made a slight change by using a const (not let) to narrow the type

This is more readable, and it's idiomatic JS

Tragically, and surprisingly, TypeScript < 4.4 doesn't like it

Let's go to the playground and look at it
- the code runs - this is correct code
- TS doesn't remember that a type has been narrowed
- but with 4.4 it does!

</aside>

[Type narrowing with a const:](https://www.typescriptlang.org/play?ts=3.3.3#code/C4TwDgpgBAcgrgWwEYQE4HlUGVioJYB2A5lALxQGIqpQA+UAzroUQFCsBmcBAxsHgHsCUAIYATMQApgACxYMAKgICCEgFywqaTDnzEA2gF0AlBsrI0UAN6sodqABsIwKMAHARDslAAMAblt7DgEaSR4hJlc5YiVVMSgBDij5WIlja0D7e3CCSIYZATgHMQBhATQeCCV4CxpyUEhE5JiVCTJScgByJj0iToDMrKg8JMl8wuKyiqqBGup0myGl13dPKABqcjm0aWiiVLFjAOWoAF8oCAcGaEWT+zcPL03m-daxY+XTwa+s1Gc4VDCB6eAJfVg5BgCJwAOgcAiIknEUn0AEYADRQToAdk6GM6AGZcVAAJwmYxAA)

```ts
function add(thingsToAdd: NumberOrString[]): number {
    let total = 0;
    for (const thingToAdd of thingsToAdd) {
        const shouldCoerceToNumber = 
          typeof thingToAdd === 'string';

        if (shouldCoerceToNumber) {
            total += Number(thingToAdd);
        } else {
            total += thingToAdd;
        }
    }
    return total;
}
```

---

<!-- .slide: style="text-align: left;" -->
<aside class="notes">

So far we've type narrowed primitives

Let's look at discriminated unions

Note that multiple destructured types does not work

</aside>


[Type narrowing a discriminated union:](https://www.typescriptlang.org/play?ts=4.4.2#code/C4TwDgpgBAcgrgWwEYQE4HlUGVioJYB2A5lALxQBQU1UA3lKJAFxQDkhwERarA3FABMAhsCEsCiFKn4BfStQA+dBuAgtWnAB7A+gkWKgBnXIRIyKFAGZwCAY2B4A9gShCBAgBTAAFqcMAVRwBBdxZ4ZDRMHHxiAG0AXQBKcUk0OioaABsIYAZHUUyyKAAGXgzqS0dUKA9bZ2MGX2JAkIEoR0tGvxb3RPSaAag6ggbDb0c4TIEAYUc0WwhA8Kkin1MegQA6RmhSPbYtHTLywbxOjzGJqdn5xcdltD7aE8GaYHyhQoBqcgfULyaRA2m2EokSZVe1DkEEyhmgz0hg3eBSgPy6zWC7hB+ghkPMA3xNFQOTgqBcyM+ZXMFGGhkc2U2mUcRA8JzcnliLxo9FBBgAjAAaFTMNgcLg8KAyIVc6g8-TqADsrCFO3Uh1YkuliLlonUAGZlcK1AcINoNVL5JCdQYAJwq1TqMXcVDmk5JCiJIA)

```ts
type NumberOrString = 
    { type: 'integer'; data: number; } 
  | { type: 'text'; data: string }

function add(thingsToAdd: NumberOrString[]): number { /**/ }

console.log(
    add([
        { data: 1, type: 'integer' }, 
        { data: '7', type: 'text' }, 
        { data: '3', type: 'text' }, 
        { data: 9, type: 'integer' }
    ])
)
```

---

<!-- .slide: style="text-align: left;" -->
<aside class="notes">

We're not done! There's even more
we can do to enhance our type safety

What can it be?

It's a feature named template literal types 
First shipped with 4.1 and keeps getting better

</aside>

### Bonus points!

[Template literal strings](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)

```ts
type World = "world";
type Greeting = `hello ${World}`;
// ...
type Greeting = "hello world"
```

---

<!-- .slide: style="text-align: left;" -->
<aside class="notes">

But wait! There's still a problem!

Strings that aren't numbers!

What about them eh?

</aside>

### Strings that are only digits

[Template literal strings:](https://www.typescriptlang.org/play?ts=4.4.2#code/C4TwDgpgBAysBOBLAdgcwOqOACwCKNSwGcB5ZAGxCgF4oADAEgG9kBXAWwCMJ4BfOgFChIUAHIdu8EvDhI0NKGy48oAH1gIUGLHgLEylAQIBmrZAGNgiAPbIoAQwAmjgBQ4tRACrWAgs4BcYhI80rJaANoAugCUgUqSUEwCUClQ5BDAUMDWwPbkCgAMANzJqcbW8FAu5rZEme5o3n6OUNbGWdgeTc7RiaWpqTXIdVBE2Nas5I4AwtY85hDe4sqVtMIQbR1a3S3Ue1AA5HVyqAcl-QNQiO0uYxNTs-OL1suSvUmXn1k5eVAA1LRXjw3J1Gr4eiUvlBeFAIOQiNAPlDUtlcvkAVswc1IV9eBc8QN4BlWPA7Ki8iU8QIhkRrOkAHTkayoFxOVzhACMABpDgB2A48g4AZgFUAAnDFokA)

```ts
type StringWithDigitsOnly = `${number}`
type NumberOrString = number | StringWithDigitsOnly
```

---

<!-- .slide: style="text-align: center;" -->
<aside class="notes">

Finally, here's something in a similar space
which perhaps TS may support in future

</aside>

### [An idea for the future](https://www.typescriptlang.org/play?ts=4.4.2#code/MYewdgzgLgBAhgEwQJwKYQumBeGZUDuMAsnAA4A80yAlmAOYA0M1d9AfABQBQMfMAbQEByAFYgAFmDABPAPpoaAGyUzhzYQBlwCcMIC6+7gEoA3N1CRYqAB41oEHPCRoM6AHQS4ETmMnT5RRU1M25uGgAzGE5beygIYxgAb15+S2hnFHQIAC4WKFoGJ0Qstwh3elQoX3EpWQVUZVVhUP4YdJAlVHclEHpOEtcE7gBfbiA)

```ts
const addresses = new Map<string, string>(
    [['johnny_reilly', 'London']]
);
const exists = addresses.has('johnny_reilly');

if (exists) {
    const address: string = addresses.get('johnny_reilly');
    console.log(address)
}
```

---

<!-- .slide: style="text-align: center;" -->
<aside class="notes">

Finally, here's something in a similar space
which perhaps TS may support in future

TypeScript allowing number only string types: https://stackoverflow.com/questions/66294091/how-to-create-a-type-that-describes-string-with-only-digits 

</aside>

### TypeScript: getting better all the time

- [PR that landed control flow analysis of aliased conditional expressions and discriminants](https://github.com/microsoft/TypeScript/pull/44730)
- [GitHub issue from 2016 it resolved](https://github.com/microsoft/TypeScript/issues/12184)
- [Original blog post](https://blog.logrocket.com/typescript-4-4-and-more-readable-code/)

